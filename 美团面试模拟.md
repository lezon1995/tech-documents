**美团内推（一面+二面+三面）面试题目**

# 美团一面（电话） 

1.  自我介绍

   > 您好我是XXX...

2.  项目介绍

   > ...

3.  Redis介绍

4.  了解redis源码么

   > 不好意思，我没有看过redis源码

5.  了解redis集群么

   > 我有过了解，redis集群可以做`一主多从`架构来实现`高可用`，这种架构的配置就是
   >
   > 一台服务器作为`master`节点，负责处理来自客户端的`写请求`
   >
   > 多台服务器作为`slave`节点，负责处理来自客户端的`写请求`
   >
   > `master`节点完成`写请求`之后，会将数据同步到其他`slave`节点，形成多个数据备份
   >
   > 当`master`节点出现故障的时候，`redis哨兵`机制可以从身下的`slave`节点中
   >
   > 选出一个新的`master`来提供服务。
   >
   > 但是这种`一主多从`的架构只保证了`高可用`，当`master`节点数据达到机器上限的时候，
   >
   > 就必须删除部分数据，来腾出空间存放新的数据
   >
   > 删除数据有两种方法 `过期策略`和`内存淘汰`
   >
   > `过期策略`分为`定期过期`和`惰性过期`，一般是这两种策略配合`使用`
   >
   > `内存淘汰`分为`no-eviction`，`allkeys-lru`，`allkeys-random`，`volatile-lru`，`volatile-ttl`，`volatile-random`
   >
   > 但是如果数据量确实很大，超过了一台机器的极限，这个时候就需要做redis集群就需要`多主多从`架构来实现`高可用`和`高并发`。
   >
   > `多主多从`是指多台`master`节点，每一台`master`节点对应多台`slave`节点，这样一来就对redis集群实现了横向扩展，集群的总容量=多台`master`节点的容量之和。
   >
   > 多台`master`节点均衡分配读请求，均衡分配的算法可以使用redis提供的`redis slot`算法，`一致性hash`算法
   >
   > `redis slot`算法中的`slot`一共有`16384`个槽，然后平均分配区间给不同的节点，然后对`key`哈希取模或者位运算来的到一个`0~16383`之间的数，根据不同节点的范围来确定该`key`应该写入到哪个节点上。
   >
   > `一致性hash`算法是对`master`节点进行hash路由到一个圆环某个位置上，圆环大小是`2^32-1`，然后将`key`的hash也路由到圆环的某个位置上，找到这个`key`的位置顺时钟最近的那个节点，然后将`key`写入到那个节点上面。
   >
   > 然后每个`master`的`slave`节点负责同步数据，负责读请求。
   >
   > 然后通过`哨兵`集群来监控整个`redis集群`的节点情况，如果其中某个`master`节点挂掉了，就。将在其对应的`slave`节点中选举出一台新的`master`节点。

6.  `HashMap`的原理，增删的情况后端数据结构如何位移

   > 在1.7以前，hashmap是由`数组`加`链表`的方式实现的，如果大量的`key`的hash最终定位到同一个数组下标，那么该下边出会生成一个很长的链表，假如现在需要查询链表末尾的`key`，那么查询过程就比较耗时，相当于从头遍历一个链表，时间复杂度为`O(n)`
   >
   > 在1.8的时候，hashmap任然是由`数组`加`链表`的方式实现，但是在`链表`这块做了很大的优化
   >
   > 如果大量的`key`的hash最终定位到同一个数组下标，那么此处会产生一个链表，当链表节点个数增加达到了hashmap中定义的`treeify_threshold=8`的时候，链表会转变为一个`红黑树`，当红黑树节点个数减少到了`UNTREEIFY_THRESHOLD=6`的时候，红黑树会退化为一个链表
   >
   > 这么做是因为`红黑树`具有比较好的查询性能，时间复杂度为`O(logn)`，当节点个数>=8的时候，红黑树的查询效率比链表要好，后来节点数<=6的时候，体现不出红黑树的性能，所以就退化成链表了。
   >
   > 如果当数据超过了`DEFAULT_INITIAL_CAPACITY`*`DEFAULT_LOAD_FACTOR`的时候，就是16x0.75=12，hashmap会进行扩容，调用`resize()`方法，将当前容量乘以2，再对`key`进行`rehash`，重新定位`key`的位置，完成扩容

7.  hashmap容量为什么是2的幂次

   > 因为在hashmap中，对`key`的定位方法是这样的
   >
   > 通过`key`的`高16位`对`低16位`进行`与运算`，得到一个扰动之后的`hash`值
   >
   > 然后拿`hash`值对`容量-1`进行`与运算`
   >
   > hashmap默认初始容量为16
   >
   > 15的二进制位是`0000 1111`
   >
   > 与运算之后就可以得到一个范围在0~15之间的值
   >
   > 每次扩容都是2倍，是为了保证`hash`对`容量-1`做`与运算`的时候能够快速的高效的得到一个区间值

8.  hashset的源码

   > hashset源码中维护了一个hashmap，通过hashmap的键唯一的特性，来实现hashSet的功能

9.  object类你知道的方法

   > wait()，wait(long)，wait(long,int)，notify，notifyAll，clone，finalize，hashcode，equals，tostring，getClass，registerNatives
   >
   > 

10.  hashcode和equals

11.  你重写过hashcode和equals么，要注意什么

    > 重写过，要注意两个方法要同时重写
    >
    > `equals`为true的两个对象，其`hashcode`一定要相等
    >
    > `equals`为false的两个对象，其`hashcode`可能相等，也可能不相等
    >
    > `hashcode`相等的两个对象，`equals`不一定相等
    >
    > `hashcode`不相等的两个对象，`equals`为一定false

12.  假设现在一个学生类，有学号和姓名，我现在hashcode方法重写的时候，只将学号参与计算，会出现什么情况？

    > 不会出现什么情况，因为hashcode没有用作其他途径

13.  往set里面put一个学生对象，然后将这个学生对象的学号改了，再put进去，可以放进set么？并讲出为什么

    > 可以，因为put的时候是调用map的put方法，先获取对象的hashcode，假设第一次put进去的时候获取的hashcode为1，但是后面将对象的学号改了，所以该对象的hashcode也会变，假设在第二次put进去的时候获取的hashcode为2，1！=2，所以可以放进set

14.  Redis的持久化？有哪些方式，原理是什么？

    > redis持久化分为
    >
    > - AOF
    >
    >   AOF持久化是将每一条写操作命令追加到一个日志文件中，优势是`文件写入速度快`，`数据不易丢失`
    >
    >   缺点是`日志文件会越来越大`
    >
    > - RDB
    >
    >   RDB方式是对redis中的数据执行周期性的持久化，RDB的优势是`恢复数据速度快`，缺点是`可能会丢失数据`

15.  讲一下稳定的排序算法和不稳定的排序算法

    > 稳定：
    >
    > - 冒泡、插入、归并、统计、计数、基数
    >
    > 不稳定
    >
    > - 选择、快速、堆、希尔

16.  讲一下快速排序的思想

    > 快速排序的思想是取一个中轴值`pivot`，一般取数组中间位置的数
    >
    > 然后以pivot为标准
    >
    > `pivot`左边的数要全部小于`pivot`
    >
    > `pivot`右边的数要全部大于`pivot`
    >
    > 然后在左右数组中各取去一个中轴值，继续按上面的规则来处理，形成递归
    >
    > 直到最后递归到每一个小数组中的只剩下一个元素

# 美团二面（现场） 

1.  自我介绍

2.  讲一下数据的acid

   > ACID指的是原子性Atomicity、一致性consistency、隔离性isolation、持久性durability

3.  什么是一致性

   > 一致性是指`数据库事务不能破坏数据的完整性以及业务上的一致性`，就是假如两个人转账，两个人资产一共有2000元，那么不管事务成功还是失败，两个人的总资产不能变

4.  什么是隔离性

   > 隔离性是指不同的事务之间互不影响

5.  Mysql的隔离级别

   > mysql事务隔离级别有四个
   >
   > - 读未提交
   > - 读已提交
   > - 可重复读
   > - 串行化

6.  每个隔离级别是如何解决

   > - 读未提交
   > - 读已提交
   > - 可重复读
   > - 串行化

7.  Mysql要加上nextkey锁，语句该怎么写

   > 行锁
   >
   > - 共享锁（读锁）也叫S锁，`lock in share mode`手动开启，读读共享，读写互斥
   > - 排他锁（写锁）也叫X锁，`update`、`delete`、`insert`会自动加上排他锁，`select`需要手动加上`for update`开启，写锁跟任何锁都互斥
   >
   > 表锁
   >
   > - 意向共享锁，也叫IS锁，在有一行数据加共享锁之前，会先将这张表加上一个意向共享锁，相当于一个标志位，目的是为了在其他session想对该表加表锁的时候，会直接失败，不然的话就需要检查配每一行数据。意向共享锁的存在就是为了`免去检查数据的消耗，提升加锁的效率`
   > - 意向排他锁，也叫IX锁，同上

8.  Java的内存模型，垃圾回收

   > Java内存模型分为堆、`栈`、`方法区`、`本地方法栈`、`程序计数器`

9.  线程池的参数

   > `corePoolSize`
   > `maximumPoolSize`,
   > `keepAliveTime`,
   > `unit`,
   > `workQueue`,
   > `threadFactory`,
   > `handler`

10.  每个参数解释一遍

    > `corePoolSize`核心线程数量
    > `maximumPoolSize`,最大线程数量
    > `keepAliveTime`,有效时间
    > `unit`,时间单位
    > `workQueue`,工作队列
    > `threadFactory`,线程工厂
    > `handler`拒绝策略

11.  然后面试官设置了每个参数，给了是个线程，让描述出完整的线程池执行的流程

    ![img](https://uploadfiles.nowcoder.com/files/20190119/7380095_1547900839314_4685968-fa16ddf5e4094e75.png)

12.  Nio和IO有什么区别

    > NIO是同步非阻塞IO
    >
    > IO其实就是指BIO，同步阻塞IO
    >
    > BIO面向流，在客户端和服务端读的时候都是阻塞的，需要有一方写入，另一方才能读到。BIO每连接一个客户端都会新建一个线程来处理客户端的socket，如果客户端数量很大的话，可能将BIO的线程资源给耗尽，而且每个线程读取的时候会阻塞，假如客户端一直不写，那么客户端一直阻塞，这样大大浪费线程的性能。
    >
    > NIO是面向缓冲区的，在客户端和服务端读取的时候都是非阻塞的，当某一方写入的时候，另一方会接收到事件，然后再去读取内容。而且NIO的是使用的IO多路复用机制来处理客户度请求，有一个selector线程会一直监听来自客户端的事件，假如有大量客户端连进来，selector线程会将每个请求注册到多路复用器上，然后只要客户端有事件，NIO的工作线程就会去处理这些事件，所以哪怕有大量客户端连接，也不会消耗服务端的大量资源。

13.  Nio和aio的区别

    > AIO是异步非阻塞，在客户端连接到服务端之后，在客户端写入数据之后，服务端会由`操作系统`监听到请求，然后主动告诉服务端有请求过来了，然后调用服务端的处理方法，在NIO中是selector线程不断去询问是否有事件

14.  Spring的aop怎么实现

    > 通过java动态代理方式

15.  Spring的aop有哪些实现方式

    > 通过XML配置文件，来定义`Advice`通知对象、`Aspect`切面、`Pointcut`切点
    >
    > 通过`@Aspect`、`@before`、`@after`等注解

16.  动态代理的实现方式和区别

    > 动态代理分为两种方式
    >
    > - JDK自带的动态代理，实现`InvocationHandler`接口，重写`invoke`方法，然后同过`Proxy.newProxyInstance`来生成代理对象
    > - 使用CGLiib代理，创建一个代理类实现`MethodInterceptor`接口，然后重写`intercept`方法，然后使用`Enhancer`类`setSuperclass`，`setCallback`方法，创造一个继承自被代理对象的代理对象
    >
    > jdk自带的动态代理是通过实现接口实现
    >
    > CGLiib动态代理是通过继承父类实现

17.  Linux了解么

18.  怎么查看系统负载

    > uptime
    >
    > ```verilog
    > 10:19:04 up 257 days, 18:56, 12 users, load average: 2.10, 2.10,2.09
    > ```

19.  Cpu load的参数如果为4，描述一下现在系统处于什么情况

20.  Linux，查找磁盘上最大的文件的命令

    > 我们可以重复执行find命令来查找大文件，例如：`find / -type f -size +5G` 找到大于5G的文件。 `find / -type f -size +1G` 找到大于1G的文件
    >
    > 通过du命令查看此文件的大小：`du -h /usr/local/apache2/logs/access_log`

21.  Linux，如何查看系统日志文件

    > tail -1000f {log.name}

22.  手撕算法：leeetcode原题 22，Generate Parentheses，给定 n 对括号，请写一个函数以将其生成新的括号组合，并返回所有组合结果。

# 美团三面（现场） 

1. 三面没怎么问技术，问了很多技术管理方面的问题

2. 自我介绍

3. 项目介绍

4. 怎么管理项目成员

5. 当意见不一致时，如何沟通并说服开发成员，并举个例子

6. 怎么保证项目的进度

7. 数据库的索引原理

   > 索引是对数据表中一列或多列的值进行排序的一种结构，使用索引可以提高查询效率
   >
   > 在`InnoDB`中，索引是通过`主键`来构建一颗`B+树`
   >
   > 然后将所有的数据信息全部放在`叶子节点`上
   >
   > 通过主键查询，能够以O(logn)的时间复杂度查询到数据
   >
   > 在`MyISAM`中，索引是通过`主键`来构建一颗`B+树`
   >
   > 然后将所有的数据的`存储地址`全部放在`叶子节点`上
   >
   > 通过主键查询，能够以O(logn)的时间复杂度查询到数据的地址
   >
   > 然后通过地址再去`.myd`文件中查询数据文件

8.  非聚簇索引和聚簇索引

    > `聚簇索引`指的是数据库的`索引`与`数据`存在同一个文件中
    >
    > `非聚簇索引`指的是数据库的`索引`与`数据`不存在同一个文件中

9. 索引的使用注意事项

   > 使用索引的时候，需要注意
   >
   > - 不要使用`NOT IN`，`<>`，`!=`这样的条件，离散型太差，不能精确确认，
   > - 不要使用`%`开头的模糊查询
   > - 不要使用正则
   > - 不要对索引进行运算
   > - 不要使用隐式数据转换，比如字符类型的年龄，但是用数字去匹配
   > - 不要使用逻辑表达式`and`、`or`
   > - 使用联合查询的过程中，不要使用范围查询，这样会让范围查询条件后面的索引列失效

10. 联合索引

    > 联合索引是针对对多个列加索引的一种高效的索引方式

11. 从底层解释最左匹配原则

    > `最左匹配原则`是指在联合索引查询的时候，如果查询条件中没有联合索引的第一个列，那么就不会使用到索引
    >
    > 如果条件中有对第一个列进行精确匹配，那么就会用到索引
    >
    > 如果条件中有对第一个列进行精确匹配，并且对第二列进行范围查询，那么就会用到索引，第二列后面的列就不会使用到索引

12. Mysql对联合索引有优化么？会自动调整顺序么？哪个版本开始优化？

    > 有，会自动调整where后面的条件的顺序，假如联合索引是`(a,b,c)`那么`where b=1 and c= 1 and a=1`会被mysql自动优化为联合索引的顺序`where a=1 and b= 1 and c=1`
    >
    > 应该是`5.7`，[MySQL 5.7 优化](https://blog.csdn.net/qq_22421145/article/details/80048943)

13. Redis的应用

14. Redis的持久化的方式和原理

15. 技术选型，一个新技术和一个稳定的旧技术，你会怎么选择，选择的考虑有哪些

16. 说你印象最深的美团点评技术团队的三篇博客

    > [MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)
    >
    > [不可不说的Java锁事](https://tech.meituan.com/2018/11/15/java-lock.html)
    >
    > [Java NIO浅析](https://tech.meituan.com/2016/11/04/nio.html)

17. 最近在学什么新技术

    > 分布式、微服务相关的

18. 你是怎么去接触一门新技术的

    > 先去看看这门技术是在什么场景应用的，有个大致的了解之后我会去网上搜一下，看看详细的解释，然后自己去官网看下`quick start`，自己写个demo看看具体怎么用，然后分析一下它好不好用，用了之后会有什么优点和缺点

19. 会看哪些书

    > effective java
    >
    > java编程思想
    >
    > 然后别的一些互联网公司员工写的一些内部架构与设计之类的书
    >
    > 就是比较实用的一些书

20. 怎么选择要看的书