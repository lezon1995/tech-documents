# 垃圾回收算法

1. ## 标记清除(老年代)

   > ### 适用场合:
   >
   > **<u>存活对象比较多的场景,老年代</u>**

   > ### 缺点:
   >
   > **<u>容易产生内存碎片,如果此时new了一个大于最大连续内存的对象的话,就会提前出发垃圾回收</u>**

2. ## 标记复制(新生代)

   > ### 适用场合:
   >
   > **<u>存活对象比较少的场景,新生代</u>**

   > ### 缺点:
   >
   > **<u>需要一块儿新的内存空间</u>**
   >
   > <u>**需要复制移动内存**</u>

3. ## 标记整理(老年代)

   > ### 适用场合:
   >
   > **<u>存活对象多,老年代</u>**

4. ## 分代回收

   > 在不同年代使用不同的算法，从而使用最合适的算法
   >
   > 新生代存活率低，可以使用<u>**复制算法**</u>。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用<u>**标记清除**</u>或者<u>**标记整理**</u>算法。

# 垃圾回收机制

1. 新产生的对象优先分配在**eden**区（除非配置了**-XX:PretenureSizeThreshold**，大于该值的对象会直接进入年老代）；

2. 当**eden**区满了或放不下了，这时候其中存活的对象会复制到**from**区

   > 这里，需要注意的是，如果存活下来的对象**from**区都放不下，则这些存活下来的对象全部进入年老代。之后**eden**区的内存全部回收掉。

3. 之后产生的对象继续分配在**eden**区，当**eden**区又满了或放不下了，这时候将会把**eden**区和**from**区存活下来的对象复制到to区（同理，如果存活下来的对象to区都放不下，则这些存活下来的对象全部进入年老代），之后回收掉**eden**区和**from**区的所有内存

4. 如上这样，会有很多对象会被复制很多次（每复制一次，对象的年龄就+1），默认情况下，当对象被复制了15次（这个次数可以通过：**-XX:MaxTenuringThreshold**来配置），就会进入年老代了

5. 当年老代满了或者存放不下将要进入年老代的存活对象的时候，就会发生一次Full GC（这个是我们最需要减少的，因为耗时很严重）

# 垃圾回收类型

1. ## MinorGC

   > 对新生代进行垃圾回收,不会影响到老年代.
   >
   > 因为新生代的对象大多死亡频繁
   >
   > 所以MinorGC非常频繁
   >
   > 一般MinorGC使用速度快 效率高的算法

2. ## FullGC

   > 也叫MajorGC
   >
   > 对整个堆进行回收，包括**新生代**和**老年代**
   >
   > 由于FullGC需要对整个堆进行回收 所以比MinorGC要慢
   >
   > 因此应该尽可能减少Full GC的次数
   >
   > 导致FullGC的原因包括：
   >
   > <u>**老年代被写满**</u>、<u>**永久代（Perm）被写满**</u>和<u>**System.gc()**</u>被显式调用等

# 垃圾回收算法总结

1. ## 年轻代:<u>复制算法</u>

   > 1) 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。
   >
   > 2)新生代内存按照8:1:1的比例分为一个**eden**区和两个survivor(**survivor0**,**survivor1**)区。一个**eden**区，两个Survivor区(一般而言)。大部分对象在**eden**区中生成。回收时先将**eden**区存活对象复制到一个**survivor0**区，然后清空**eden**区，当这个**survivor0**区也存放满了时，则将**eden**区和**survivor0**区存活对象复制到另一个**survivor1**区，然后清空**eden**和这个**survivor0**区，此时**survivor0**区是空的，然后将**survivor0**区和**survivor1**区交换，即保持**survivor1**区为空，如此往复。
   >
   > 3) 当**survivor1**区不足以存放 **eden**和**survivor0**的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC(Major GC)，也就是新生代、老年代都进行回收。
   >
   > 4) 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等**eden**区满了才触发)。

2. ## 老年代:<u>标记清除/标记整理</u>

   > 1) 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
   >
   > 2) 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。
   >
   > 以上这种年轻代与年老代分别采用不同回收算法的方式称为”分代收集算法”，这也是当下企业使用的一种方式
   >
   > 3) 每一种算法都会有很多不同的垃圾回收器去实现，在实际使用中，根据自己的业务特点做出选择就好。