# 最新阿里技术三面模拟

## 一面 

1.自我介绍

2.谈一个你觉得你学到最多的项目，使用了什么技术，挑战在哪里

> 订单推送模块，使用到了`netty`，因为第一次将`netty`运用到实际工作当中，所以一定要确保它不会出现问题。
>
> 难点在，要保持pad端和windows端的连接是时刻通畅的，所以我想了好多办法来确保连接可靠，比如在检测到连接断开的时候，pad会播报提示语音，并且弹窗提示，然后在windows端新增心跳机制，如果心跳传不过来，就尝试重新连接pad端，重试次数超过3次就语音播报，来进行人工确保连接可靠。

3.Spring的bean的作用域？（比如：**singleton，prototype等**）

> - singleton
> - prototype
> - request
> - session
> - global-session

4.Spring的IOC实现原理？没有无参构造函数能实例化吗？有参构造函数注入？（xml配置）

> IOC的实现是通过`beanFactory`来实现，在启动spring的时候，会加载`beanFactory`的实现类，然后会去加载bean的xml配置文件，和代码中打了`@bean`注解的类，然后解析xml文件，通过反射加载bean标签中配置的类，和执行`@bean`注解的方法，将其生成的对象放入`beanFactory`ioc容器中

5.通过反射，谈到了方法区，然后，类加载机制？

> 方法区中主要存放了类的一些相关信息，还有常量池
>
> 类加载机制是采用双亲委派机制，从下到上询问是否能够加载类，如果最上级都说不行，才让下级类加载器去加载类

6.synchronized的实现原理？Volatile能保证原子性吗？为什么？

> synchronized实现原理是通过一个叫做监视器（monitor）的东西，java代码经过编译之后，会在synchronized处加上一个`monitorenter`和`monitorexit`的指令，每个对象都有一个`monitor`，当线程执行到`monitorenter`的地方，会尝试获取锁住对象的`monitor`，如果获取到了，在释放之前，任何线程再到`monitorenter`这个地方都会阻塞
>
> Volatile不能保证原子性
>
> 因为Volatile int a=0；
>
> a++;始终都是一个非原子操作
>
> 当两个线程对执行a++的时候
>
> 线程1将主内存的a=0，复制到工作内存中a=0
>
> 挂起
>
> 线程2也将主内存的a=0，复制到工作内存中a=0
>
> 线程2执行a++，（`a++是不是原子操作，相当于三步，1 获取a的值 2 获取a+1的值 3 将a+1的值赋值给a`）在执行完后面的a+1时得到值1，此时线程2倍挂起
>
> 线程1执行a++，在执行完后面的a+1时得到值1，此时将1赋值给a，由于内存可见性，a=1迅速刷新回主内存
>
> 线程2立马看见主内存的a=1，让后将最新的值复制到工作内存，`注意`，此时工作内存中的a=1，但是由于刚才已经完成了`a+1`这个操作，所以现在相当于是执行一个赋值操作，将刚刚得到的1赋值给a（a此时为1），也就相当于把1赋值给已经为1的a
>
> 最终结果a=1

7.hashmap和concurrenthashmap的size方法怎么实现的

> `hashmap`的`size`方法就是直接返回size成员变量
>
> `concurrenthashmap`的size方法是维护了`counterCells`，和`baseCount`这两个成员变量
>
> 当没有并发的时候`counterCells`为`null`，`baseCount`就等于map的size
>
> 但是一旦并发很高的时候，就会在 `put()` 方法最后会调用 `addCount()` 方法
>
> 然后同过`CAS`来对`baseCount`自增，如果`cas`失败，则对`counterCells`进行`CAS`
>
> 最终在`size`的时候，`counterCells`不为空，就对`counterCells`数组进行遍历，然后递加里面的`value`

8.JVM的调优参数？（-Xmn，-Xms等具体参数设置）

> -Xmn 新生代初始大小
>
> -Xmx 最大堆内存
>
> -Xms 初始化堆内存
>
> -Xss java栈的大小
>
> -XX:NewRatio=n 新生代与老年代比例 1:n
>
> -XX:SurvivorRatio=n survivor:eden 1:n
>
> -XX:+PrintGCDetails 打印GC详细日志

9.线程池优点，参数，如果我想实现newSingleThreadPoll，应该怎么配置，构造方法传什么参数

> new ThreadPollExecutor(1,1,0L,TimeUnit.MILLISECONDS,new `LinkedBlockingQueue`)

10.mysql死锁，怎么解决，如果不要求执行顺序，死锁怎么解决

> - `控制顺序`
>
>   以固定的顺序访问表和行。比如两个更新数据的事务，事务A 更新数据的顺序 为1，2；事务B更新数据的顺序为2，1。这样更可能会造成死锁。
>
> - `拆分事务`
>
>   大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小
>
> - `降低隔离级别`
>
>   如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁
>
> - `创建索引`
>
>   可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大

11.ioc和aop原理

12.线程的五态？转化过程？

13.TCP三次握手，为什么三次握手？

> 在网络通信的时候，一般使用TCP通信，TCP通信之前需要建立连接
>
> 连接方式就是三次握手，
>
> 第一次，由客户端向服务端发起一个SYC，
>
> 第二次，服务端收到SYC，然后给客户端返回一个ACK，确认收到了SYC
>
> 第三次，客户端接收到了服务端的ACK确认，然后给服务端返回了一个ACK，告知客户端已经收到了服务端的确认
>
> 为什么三次握手是为了`防止已过期的连接再次传到被连接的主机`，因为第二次握手可能出现客户端没有收到服务端的确认信息，假如服务端认为客户端收到了，它就认为通信已经建立了，然后等待客户端传送数据过来，但是事实上客户端并没有收到，所以客户端会继续等待，等待一段时间之后，会重新发送第一次请求连接，而此时服务端一直等待数据而不是请求连接，所以会直接丢弃报文，继续等待数据，而客户端却只能一直发送请求连接，从而造成一种死循环，客户端不断发送请求连接，服务端一直丢弃请求连接
>
> 有了第三次握手后，当客户端收到第二次握手的确认时，会告知服务端它收到了，当客户端没有收到第二次握手的确认时，服务端会重发第二次握手的确认，直到客户端告知服务端它收到了第二次握手的确认

14.JVM内存分区？（主存，工作内存，堆，栈。。。。）

15.讲一下GC？

16.为什么要用老年代和新生代？

> 因为堆中的不同的对象的存活的时间不一样，为了区分，就将堆分为新生代和老年代，新生代都是些新的对象，老年代都是些存活时间长的对象，针对不同的对象使用不同的垃圾回收算法，能够提高GC的效率

17.新生代进入老生代的情况？

> 1. 当新生代GC的时候，新对象不足以放入survivor区就会放入老年代
> 2. 当新生代的对象大小超过了JVM参数 `-XX:PretenureSizeThreshold`设置的值，就直接放入老年代
> 3. 当新生代中的对象年龄超过了JVM参数 `-XX:MaxTenuringThreshold`设置的值，就放入老年代

18.新生代的分区？

## 二面 

1.  变着法的问了一大堆线程池的知识 （主要考对应的参数）

2.  java内存模型

3.  lock和synchronized的区别

   > lock是通过java代码层面实现的锁
   >
   > synchronized是通过JVM层面实现的锁

4.  reentrantlock的实现

5.  hashmap和concurrenthashmap

6.  B+树和B-树的区别

7.  复合索引

8.  聚集索引和非聚集索引的区别？

9.  数据库索引 主键和唯一索引有什么区别

10.  索引失效条件，什么时候该建立索引

    > 应该在经常作为条件查询的字段上加索引
    >
    > 在分辨度较高的字段上加索引

11.  innDB和MyISAM的区别？

12.  线程安全（阻塞同步，非阻塞同步，无同步）

## 三面 

**主要高并发和分布式架构设计**

1.  服务器模型以及之间的区别
2.  线程池的设计
3.  线程池如何做负载均衡
4.  如何实现线程调度算法
5.  复合索引是如何实现的？
6.  如何设计单点登录，单点登录的原理
7.  redis缓存和memcached缓存的区别，以及各自的优劣势
8.  大型高并发网站如何做性能优化：Web性能、数据库性能、应用服务器性能等。
9.  实践中如何优化MySQL:SQL语句及索引的优化、数据库表结构的优化、系统配置的优化、硬件的优化
10.  分库分表和读写分离如何设计
11.  微服务架构：dubbo和springcloud的区别，以及各自对应的使用场景。