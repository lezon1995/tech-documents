# 多线程

## 1 stop()和suspend()方法为什么不推荐使用

- 反对使用`stop()`方法，是因为它不安全

  > 它会**解除**由线程获取的所有**锁定**
  >
  > 而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们
  >
  > 结果很难检查出真正的问题所在

- `suspend()` 方法容易发生死锁

  > 调用 `suspend()` ，线程会被挂起，但是仍然持有锁
  >
  > 其他任何线程都不能访问锁定的资源，除非被挂起的线程恢复运行。
  >
  > 对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。
  >
  > 应该使用`wait()`命其进入等待状态

## 2 sleep() 和 wait() 有什么区别

- `sleep()`

  > 线程进入`TIMED_WAIT`状态，但不释放已经获得的锁
  >
  > 休眠指定时间过后，进入`RUNNABLE`状态，等待CPU分配时间片才能执行，进入`RUNNING`状态

- `wait()`

  > 线程进入阻塞状态，释放已经获取到的锁
  >
  > 只有其他线程调用了 `notify()`或者 `notifyAll()`
  >
  > 线程才会退出阻塞状态，进入`RUNNABLE`状态，重新参与锁的竞争
  >
  > 只有竞争到了才会继续执行

## 3 synchronized 和Lock 的区别

- 相同点

  > `Lock` 能完成 `synchronized` 所实现的所有功能

- 不同点

  > `Lock` 有比 `synchronized` 更精确的线程语义和更好的性能`synchronized` 会自动释放锁，而 `Lock` 一定要求程序员手工释放，并且必须在 finally从句中释放
  >
  > `Lock` 还有更强大的功能，它的 `tryLock` 方法可以非阻塞方式尝试获取锁

## 4 volatile功能

- 保证内存可见性

  > 每个线程内部维护了一个`工作内存`
  >
  > 每个线程操作主内存中的变量时，是取一份副本到`工作内存`
  >
  > 然后操作`工作内存`，再将`工作内存`中的值写入到`主内存`
  >
  > 如果变量被`volatile`修饰
  >
  > 改变`工作内存`中的变量之后，会立即同步到`主内存`
  >
  > 假如同步之前已经有一个线程获取了旧值
  >
  > 那么旧值就直接过期了
  >
  > 线程需要重新去`主内存`中获取最新的副本

- 防止指令重排序

  > 在java字节码的执行过程中
  >
  > 通常为了执行效率，会改变某些指令的执行顺序
  >
  > 大部分情况下，这种顺序不会影响程序运行
  >
  > 但是在高并发情况下，这种顺序会存在某些隐患
  >
  > 如果变量被`volatile`修饰，会在变量前后产生`内存屏障`
  >
  > 从而禁止指令重排序

## 5 volatile 能使得一个非原子操作变成原子操作吗

在 Java 中除了 `long` 和 `double` 之外的所有基本类型的读和赋值，都是原子性操作

而 `64 位`的 `long` 和 `double` 变量由于会被 JVM 当作两个分离的 `32 位`来进行操作，所以不具有原子性，会产生字撕裂问题

但是当你定义 `long` 或 `double` 变量时，如果使用 `volatile` 关键字，就会获到（简单的赋值与返回操作的）原子性