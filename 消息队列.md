# 消息队列

## 1 为什么要使用消息队列?

	1. 系统解耦
 	2. 流量削峰
 	3. 异步调用

## 2 消息队列有什么优点?

### 优点

- **系统解耦 **

  > **有利于系统间的扩展与维护 让系统能够更专心的做自己的事情**

- **流量削峰 **

  > **能够在高并发的场景下缓解系统瞬间的超高压力**

- **异步调用 **

  > **可以将某些耗时的操作交由系统异步处理 提高了用户体验**

### 缺点

- **系统可用性降低**

  > 1. 随着系统引入外部系统依赖变多 众多系统或者依赖中只要有一个环节出现问题 就会导致整个系统不可用
  >
  > 2. 由于消息队列使系统间解耦 导致系统之间变得无感知 没使用消息队列之前 系统间直接调用成功失败结果立马就知道 但是使用了消息队列之后 某一系统出现了问题 整个系统就变得不可用

- **系统复杂性提高**

  > 引入消息队列之后 整个系统间的服务调用变得不可控 假如消息没有被成功消费 假如消息丢失 假如消息顺序打乱等等一系列问题

- **数据一致性问题**

  > 假如A系统需要调用BCD三个系统的服务 需要三个服务都调用成功才算成功 使用消息队列之后 A系统生产一条消息到MQ中之后就直接返回成功了 然后BCD三个服务收到消息异步执行 假如D服务调用失败 那么整个过程就应该算失败 但是用户收到的响应是成功的

### Kafka ActiveMQ RabbitMQ RocketMQ都有什么区别以及适用哪些场景?

| 特性       | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                                                 | Kafka                                                        |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- | ------------------------------------------------------------ |
| 单机吞吐量 | 万级 吞吐量比**RocketMQ** **Kafka**低一个数量级              | 万级 吞吐量比**RocketMQ** **Kafka**低一个数量级              | 十万级 支持高吞吐量                                      | 十万级 支持高吞吐量 一般配合大数据类的系统进行数据计算 日志采集等场景 |
| 消息可靠性 | 有较低的概率丢失数据                                         |                                                              | 经过参数优化配置，可以做到0丢失                          | 经过参数优化配置，消息可以做到0丢失                          |
| 功能支持   | MQ领域的功能极其完备                                         | 基于erlang开发，所以并发能力很强，性能极其好，延时很低       | MQ功能较为完善，还是分布式的，扩展性好                   | 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 |
| 优劣势总结 | 非常成熟，功能强大，在业内大量的公司以及项目中都有应用偶尔会有较低概率丢失消息 而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用 | erlang语言开发，性能极其好，延时很低；吞吐量到万级，MQ功能比较完备 | 接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障 | kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展 |

## 总结

```
综上所述，各种对比之后，我个人倾向于是：

 

一般的业务系统要引入MQ，最早大家都用ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；

 

后来大家开始用RabbitMQ，但是确实erlang语言阻止了大量的java工程师去深入研究和掌控他，对公司而言，几乎处于不可控的状态，但是确实人是开源的，比较稳定的支持，活跃度也高；

 

不过现在确实越来越多的公司，会去用RocketMQ，确实很不错，但是我提醒一下自己想好社区万一突然黄掉的风险，对自己公司技术实力有绝对自信的，我推荐用RocketMQ，否则回去老老实实用RabbitMQ吧，人是活跃开源社区，绝对不会黄

 

所以中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用RocketMQ是很好的选择

 

如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范
```



## 3 引入消息队列后,如何保证其高可用性?

建立集群

## 4 如何保证消息不被重复消费啊（如何保证消息消费时的幂等性）？

（1）比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update一下好吧

（2）比如你是写redis，那没问题了，反正每次都是set，天然幂等性

（3）比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，**<u>里面加一个全局唯一的id</u>**，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。

​		还有比如基于数据库的**<u>唯一键</u>**来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会有重复，因为kafka消费者还没来得及提交offset，重复数据拿到了以后我们插入的时候，因为有**<u>唯一键约束</u>**了，所以重复数据只会插入报错，不会导致数据库中出现脏数据

​		如何保证MQ的消费是幂等性的，需要结合具体的业务来看



## 5 如何保证消息的可靠性传输（如何处理消息丢失的问题）？

丢数据，mq一般分为两种，要么是mq自己弄丢了，要么是我们消费的时候弄丢了。咱们从rabbitmq和kafka分别来分析一下吧

### rabbitmq

#### 1）生产者弄丢了数据

生产者将数据发送到rabbitmq的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。



**<u>此时可以选择用rabbitmq提供的事务功能</u>**，就是生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息；如果收到了消息，那么可以提交事务（channel.txCommit）。**<u>但是问题是，rabbitmq事务机制一搞，基本上吞吐量会下来，因为太耗性能。</u>**



**<u>所以一般来说，如果你要确保说写rabbitmq的消息别丢，可以开启confirm模式</u>**，在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会给你回传一个ack消息，告诉你说这个消息ok了。如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。

 

**事务机制**和**confirm机制**最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息rabbitmq接收了之后会异步回调你一个接口通知你这个消息接收到了。

 

所以一般在生产者这块避免数据丢失，都是用confirm机制的。

 

#### 2）rabbitmq弄丢了数据

 

就是rabbitmq自己弄丢了数据，这个你必须**开启rabbitmq的持久化**，就是消息写入之后会持久化到磁盘，哪怕是rabbitmq自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，rabbitmq还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小。

 

设置持久化有两个步骤，第一个是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的数据；第二个是**<u>发送消息的时候将消息的delivery Mode设置为2</u>**，就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘上去。必须要同时设置这两个持久化才行，rabbitmq哪怕是挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。

 

而且持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，rabbitmq挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。

 

哪怕是你给rabbitmq开启了持久化机制，也有一种可能，就是这个消息写到了rabbitmq中，但是还没来得及持久化到磁盘上，结果不巧，此时rabbitmq挂了，就会导致内存里的一点点数据会丢失。

 

#### 3）消费端弄丢了数据

 

rabbitmq如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，rabbitmq认为你都消费了，这数据就丢了。

 

这个时候得用rabbitmq提供的ack机制，简单来说，就是你**<u>关闭rabbitmq自动ack</u>**，可以通过一个api来调用就行，**<u>然后每次你自己代码里确保处理完的时候，再程序里ack一把。</u>**这样的话，如果你还没处理完，不就没有ack？那rabbitmq就认为你还没处理完，这个时候rabbitmq会把这个消费分配给别的consumer去处理，消息是不会丢的。

 

### kafka

 

#### 1）消费端弄丢了数据

 

唯一可能导致消费者弄丢数据的情况，就是说，你那个消费到了这个消息，然后消费者那边自动提交了offset，让kafka以为你已经消费好了这个消息，其实你刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。

 

这不是一样么，大家都知道kafka会自动提交offset，那么只要**<u>关闭自动提交offset</u>**，**<u>在处理完之后自己手动提交offset，就可以保证数据不会丢</u>**。但是此时确实还是会重复消费，比如你刚处理完，还没提交offset，结果自己挂了，此时肯定会重复消费一次，自己**<u>保证幂等性</u>**就好了。

 

生产环境碰到的一个问题，就是说我们的kafka消费者消费到了数据之后是写到一个内存的queue里先缓冲一下，结果有的时候，你刚把消息写入内存queue，然后消费者会自动提交offset。

 

然后此时我们重启了系统，就会导致内存queue里还没来得及处理的数据就丢失了

 

#### 2）kafka弄丢了数据

 

这块比较常见的一个场景，就是kafka某个broker宕机，然后重新选举partiton的leader时。大家想想，要是此时其他的follower刚好还有些数据没有同步，结果此时leader挂了，然后选举某个follower成leader之后，他不就少了一些数据？这就丢了一些数据啊。



生产环境也遇到过，我们也是，之前kafka的leader机器宕机了，将follower切换为leader之后，就会发现说这个数据就丢了

 

所以此时一般是要求起码设置如下**<u>4个参数</u>**：

 

给这个topic设置***<u>replication.factor</u>***参数：这个值必须大于1，要求每个partition必须有至少2个副本

 

在kafka服务端设置***<u>min.insync.replicas</u>***参数：这个值必须大于1，这个是要求一个leader至少感知到有至少一个follower还跟自己保持联系，没掉队，这样才能确保leader挂了还有一个follower吧

 

在producer端设置***<u>acks=all</u>***：这个是要求每条数据，必须是写入所有replica之后，才能认为是写成功了

 

在producer端设置***<u>retries=MAX</u>（很大很大很大的一个值，无限次重试的意思）***：这个是要求一旦写入失败，就无限重试，卡在这里了

 

我们生产环境就是按照上述要求配置的，这样配置之后，至少在kafka broker端就可以保证在leader所在broker发生故障，进行leader切换时，数据不会丢失

 

#### 3）生产者会不会弄丢数据?

 

如果按照上述的思路设置了ack=all，一定不会丢，要求是，你的leader接收到消息，所有的follower都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。



## 6 如何保证消息的顺序性？

（1）rabbitmq：拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理

 

（2）kafka：一个topic，一个partition，一个consumer，内部单线程消费，写N个内存queue，然后N个线程分别消费一个内存queue即可



## 7 如何解决消息队列的延时以及过期失效问题？

假设你用的是rabbitmq，rabbitmq是可以设置过期时间的，就是TTL，如果消息在queue中积压超过一定的时间就会被rabbitmq给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在mq里，而是大量的数据会直接搞丢。

 

这个情况下，就不是说要增加consumer消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。

 

这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入mq里面去，把白天丢的数据给他补回来。也只能是这样了。

 

假设1万个订单积压在mq里面，没有处理，其中1000个订单都丢了，你只能手动写程序把那1000个订单给查出来，手动发到mq里去再补一次

## 8 消息队列满了以后该怎么处理？

如果走的方式是消息积压在mq里，那么如果你很长时间都没处理掉，此时导致mq都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。

## 9 有几百万消息持续积压几小时，说说怎么解决？

假设几千万条数据在MQ里积压了七八个小时，从下午4点多，积压到了晚上很晚，10点多，11点多



这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复consumer的问题，让他恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。



一个消费者一秒是1000条，一秒3个消费者是3000条，一分钟是18万条，1000多万条

 

所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概1小时的时间才能恢复过来

 

一般这个时候，只能操作临时紧急扩容了，具体操作步骤和思路如下：

 

1）先修复consumer的问题，确保其恢复消费速度，然后将现有consumer都停掉

2）新建一个topic，partition是原来的10倍，临时建立好原先10倍或者20倍的queue数量

3）然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue

4）接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据

5）这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据

6）等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息



## 10 如果让你写一个消息队列，该如何进行架构设计啊？说一下你的思路

其实回答这类问题，说白了，起码不求你看过那技术的源码，起码你大概知道那个技术的基本原理，核心组成部分，基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好

 

比如说这个消息队列系统，我们来从以下几个角度来考虑一下

 

（1）首先这个mq得**支持可伸缩性**吧，就是**需要的时候快速扩容**，就可以**增加吞吐量和容量**，那怎么搞？设计个**分布式的系统**呗，**参照一下kafka的设计理念**，**broker** -> **topic** -> **partition**，每个partition放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给topic增加partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？

 

（2）其次你得考虑一下这个mq的数据要不要**落地磁盘**吧？那肯定要了，落磁盘，才能**保证别进程挂了数据就丢了**。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是kafka的思路。

 

（3）其次你考虑一下你的mq的可用性啊？这个事儿，具体参考我们之前可用性那个环节讲解的kafka的高可用保障机制。多副本 -> leader & follower -> broker挂了重新选举leader即可对外服务。

 

（4）能不能支持数据0丢失啊？可以的，参考我们之前说的那个kafka数据零丢失方案

 

总结:

高可用(可以做集群) 

可扩容(可以增加机器扩大容量) 

可持久化(数据持久化到磁盘上)

其实一个mq肯定是很复杂的，面试官问你这个问题，其实是个开放题，他就是看看你有没有从架构角度整体构思和设计的思维以及能力。确实这个问题可以刷掉一大批人，因为大部分人平时不思考这些东西。



## 总结

一般而言，如果一个面试官水平还算不错，会沿着从浅入深的环节深入挖一个点。比如我吧，其实按照这个思路可以一直问下去，除了这里的7个问题之外，甚至能挑着你熟悉的一个mq一直问到源码级别非常底层。我还可能会结合项目来仔细问，我可能会先让你给我详细说说你的业务细节，然后将你的业务跟这些mq的问题场景结合起来，看看你每个细节是怎么处理的。

 

但是确实因为我们这个是面试突击型课程，不是什么kafka源码剖析课，也不是什么Rocket MQ高并发架构项目实战课程，所以只能讲到这个程度。

 

所以我们这个课程只能让你从大面儿上，基本常见问题可以回答出来。基本上mq这块你能答到这个程度，你基本知识面儿是有了，但是深度是绝对没有的。所以如果一个面试官就问问这些问题，感觉你面儿上过的去了，那就恭喜你了。但是如果碰到我这种难缠的面试官，喜欢深挖底层，细扣项目细节的，那可能确实是不行的。

 

如果你碰到人家在7个问题之外还死扣着你问的，那你最好是认一下怂，就说你确实没研究那么深过，如果你面的就是个一般的职位，那可能就过去了。就我而言，如果招聘的就是个普通职位，而你能答到这个程度，那么就觉得说的过去了。毕竟说实话，相当大比例的程序员出去面java职位的时候，mq这块还回答不到这个程度呢。你能答好这些，至少比之前一无所知的你好了一些，也比很多没准备过的程序员都好了很多。

 

最后说一个技巧，要是确实碰一个面试官连这7个问题都没问满，只要他提到mq，你自己就和盘托出一整套的东西，你就说，mq你们之前遇到过什么问题，巴拉巴拉，你们的方案是什么，自己突出自己会的东西