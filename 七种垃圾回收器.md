# 七种垃圾回收器

1. ## 新生代的垃圾回收器

   - ### Serial - 串行收集器#<u>复制算法</u>

     > Serial收集器是**新生代单线程收集器**
     >
     > 优点是 简单高效
     >
     > 是最基本 发展历史最悠久的收集器
     >
     > 在它工作的时候 必须暂停其他所有的工作线程 指导它收集完毕![img](http://p1.pstatp.com/large/pgc-image/25bd87d43312489ca65a7932b3fff7ed)

   - ### ParNew - 并行收集器#<u>复制算法</u>

     > ParNew收集器是**新生代并行收集器**，其实就是**Serial收集器的多线程版本**
     >
     > ![img](http://p1.pstatp.com/large/pgc-image/a4d99c62fe304e1cb2dc36e3f8d942c8)

   - ### Parallel Scavenge - 并行收集器#<u>复制算法</u>

     > Parallel Scavenge收集器是**新生代并行收集器**
     >
     > 追求高吞吐量，高效利用 CPU
     >
     > 该收集器的目的是——达到一个可控制的***吞吐量***
     >
     > 吞吐量就是**CPU用于运行用户代码的时间与CPU总消耗时间的比值**
     >
     > 即 **吞吐量**=**运行用户代码时间**/（**运行用户代码时间+垃圾收集时间**)
     >
     > 
     >
     > 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可用高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

     

2. ## 老年代的垃圾回收器

   - ### Serial Old - 串行收集器#<u>标记整理算法</u>

     > Serial Old是**Serial收集器的老年代版本**，它同样是一个**单线程(串行)收集器**
     >
     > 使用**标记整理**算法
     >
     > 这个收集器的主要意义也是在于**给<u>Client模式</u>下的虚拟机使用**
     >
     > *<u>jdk32位的有**client**|**server**两种模式 64位的只有**server**模式</u>*
     >
     > - **client**模式启动快,运行速度慢
     > - **server**模式启动慢,运行速度快
     >
     > **如果在Server模式下，主要两大用途：**
     >
     > （1）在**JDK1.5**以及之前的版本中与**Parallel Scavenge收集器**搭配使用
     >
     > （2）作为**CMS收集器**的后备预案，在并发收集发生**Concurrent Mode Failure**时使用

     

   - ### Parallel Old - 并行收集器#<u>标记整理算法</u>

     > **Parallel Old** 是**Parallel Scavenge收集器**的老年代版本
     >
     > 使用**多线程**和**标记整理**算法。这个收集器在1.6中才开始提供

     

   - ### CMS(`Concurrent Mark Sweep`)#<u>标记清除算法</u>

     > **CMS(`Concurrent Mark Sweep`)收集器**是一种以获取**<u>最短回收停顿时间</u>**为目标的收集器
     >
     > 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上
     >
     > 这类应用尤其重视**服务器的响应速度** 希望**系统停顿时间最短** 以给用户带来较好的体验
     >
     > CMS收集器就非常符合这类应用的需求
     >
     > 
     >
     > CMS收集器是基于**标记清除**算法实现的，它的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤：
     >
     > （1）**初始标记**
     >
     > （2）并发标记
     >
     > （3）**重新标记**
     >
     > （4）并发清除
     >
     > 其中，**初始标记**、**重新标记**这两个步骤仍然需要“**Stop The World**”
     >
     > ![img](http://p3.pstatp.com/large/pgc-image/c80a1db2aa4c438c8aefdd6f5366ac6e)
     >
     > 
     >
     > CMS收集器主要优点**：
     >
     > 1.  **并发收集**
     > 2.  **低停顿**
     >
     > 
     >
     > **CMS三个明显的缺点**：
     >
     > （1）**CMS收集器对CPU资源非常敏感**。CPU个数少于4个时，CMS对于用户程序的影响就可能变得很大，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的CMS收集器变种。
     >
     > > **-XX:+CMSIncrementalMode:**设置为增量模式。适用于单CPU情况
     >
     > （2）**CMS收集器无法处理浮动垃圾**，可能出现“**Concurrent Mode Failure**”失败而导致另一次Full GC的产生。在JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活。
     >
     > （3）CMS是基于“**标记清除**”算法实现的收集器，手机结束时会有**大量空间碎片**产生。空间碎片过多，可能会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前出发FullGC。


   

     

3. ## 回收整个Java堆(新生代&老年代)

   - ### G1收集器#<u>标记整理算法</u>

     > JDK1.7后全新的收集器 用于**取代CMS收集器**
     >
     > **G1收集器的优势：**
     >
     > 1.  独特的分代垃圾回收器,**分代GC**: **分代收集器**, 同时兼顾年轻代和老年代
     > 2.  使用分区算法, 不要求eden, 年轻代或老年代的空间都连续
     > 3.  并行性: 回收期间, 可由多个线程同时工作, 有效利用多核CPU资源
     > 4.  空间整理: 回收过程中, 会进行适当对象移动, 减少空间碎片
     > 5.  可预见性: G1可选取部分区域进行回收, 可以缩小回收范围, 减少全局停顿
     >
     > **G1收集器的运作大致可划分为一下步骤：**
     >
     > ![img](http://p3.pstatp.com/large/pgc-image/b7214d20c7be42d7a756666f1d8cfe2e)
     >
     > 
     >
     > **G1收集器的阶段分以下几个步骤：**
     >
     > 1、<u>初始标记</u>（它标记了从GC Root开始直接可达的对象）
     >
     > 2、<u>并发标记</u>（从GC Roots开始对堆中对象进行可达性分析，找出存活对象）
     >
     > 3、<u>最终标记</u>（标记那些在并发标记阶段发生变化的对象，将被回收）
     >
     > 4、<u>筛选回收</u>（首先对各个Region的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，回收一部分Region）

# JVM垃圾收集器总结

> 本文主要介绍了JVM中的垃圾回收器，主要包括串行回收器、并行回收器以及CMS回收器、G1回收器。他们各自都有优缺点，通常来说你需要根据你的业务，进行基于垃圾回收器的性能测试，然后再做选择。下面给出配置回收器时，经常使用的参数：
>
> 
>
> **-XX:+UseSerialGC**：在新生代和老年代使用串行收集器
>
> **-XX:+UseParNewGC**：在新生代使用并行收集器
>
> **-XX:+UseParallelGC** ：新生代使用并行回收收集器，更加关注吞吐量
>
> **-XX:+UseParallelOldGC**：老年代使用并行回收收集器
>
> **-XX:ParallelGCThreads**：设置用于垃圾回收的线程数
>
> **-XX:+UseConcMarkSweepGC**：新生代使用并行收集器，老年代使用CMS+串行收集器
>
> **-XX:ParallelCMSThreads**：设定CMS的线程数量
>
> **-XX:+UseG1GC**：启用G1垃圾回收器

