# 支付宝三面Java面试模拟

## 支付宝一面 

1.  介绍一下自己。

2.  项目参与的核心设计有哪些

3.  ArrayList和LinkedList底层

   > `ArrayList`底层维护的是一个数组，初始化的时候可以设置大小，默认值为10，当元素超过10的时候会扩容1.5倍，扩容的原理是通过使用`Array.copy`方法，将原数组拷贝到一个新的数组中。
   >
   > `LinkedList`底层维护的是一个双向链表，

4.  `HashMap`及线程安全的`ConcurrentHashMap`，以及各自优劣势

   > 在单线程的时候，可以使用hashmap作为键值对的存储结构，当初始化一个hashmap的时候，默认大小为16，然后通过put方法，会判断当前hashmap是否初始化数组，如果没有就初始化数组，如果初始化了就会根据Key的hash来确定其在数组中的哪个位置，假如当前位置不存在值，就直接加到数组下标出，如果存在值，则会从头遍历该节点，检查是否有节点与key同名，如果同名就替换当前位置的值，如果不存在，就往末尾添加节点，当链表长度大于8的时候，链表会进化为红黑树，如果红黑树的节点个数减少到了6个一下，那么红黑树就会退化为链表结构，如果hashmap元素个数超过了默认长度的0.75，那么hashmap就会扩容为原来的两倍，从而进行resize操作，来重新定位之前的元素所处的位置。
   >
   > hashmap线程非安全体现在多个线程对hashmap进行put操作的时候，当需要扩容的时候，多线程扩容的时候，需要重新设置原先节点的位置，和链表上的节点的链式关系，这个过程中可能会导致，出现链表成环，一旦链表上有一个环状结构，在get操作的时候就可能出现死循环。
   >
   > 为了解决线程安全，就有了`ConcurrentHashMap`这个类，在1.8中，使用链表+红黑树+CAS机制来实现线程安全。

5.  Java如何实现线程安全

   > 使用锁，`synchronized`关键字、juc包下的锁的各种实现类，`reentrantlock`可重入锁，`ReentrantReadWriteLock`可重入读写锁，

6.  Synchronized和Lock哪个更好？

   > 各有各的好处
   >
   > Synchronized在jdk6之后有了很大的优化，从`偏向锁`到`轻量级锁`到`重量级锁`，提高了Synchronized的性能
   >
   > Lock类也可以实现Synchronized的功能，而且可以手动施放锁，可以多次利用，使用方式更加灵活

7.  HashMap中的get()方法是如何实现的？

8.  HashMap可以用在哪些场景？

9.  JVM，垃圾回收机制，内存划分等

10.  SQL优化，常用的索引？

11.  还有什么问题需要问的。

## 支付宝二面 

1.  没有自我介绍，直接问做过哪些Java开发相关的项目。

   > 我做过XX项目的流水模块，XX项目的接口服务，写过Android，使用netty写过通信方面的东西，带领过三个人的小团队来开发一个项目，两个开发，一个测试

2.  对哪些技术比较熟悉？

   > 对多线程，IO这一块比较熟悉

3.  多线程状态图，状态如何流转？

   > NEW
   >
   > RUNNABLE
   >
   > BLOCKED
   >
   > WAIT
   >
   > TIMED_WAIT
   >
   > TERMINATE

4.  死锁，死锁原因

   > 死锁的产生有四个条件
   >
   > 1 资源互斥（mutex）
   >
   > 2 占有资源并且等待（hold and wait）
   >
   > 3 不可抢夺已经被占有的资源（no preempting）
   >
   > 4 循环等待（circular wait）
   >
   > 两个线程占着对方需要的资源都不释放，

5.  页锁、乐观锁、悲观锁？

   > 页锁是`BDB引擎`下专有的锁类型，但是我没有用过页锁
   >
   > 乐观锁和悲观锁是一种思想
   >
   > 乐观锁乐观地认为数据不会被修改，所以不会加锁，但是访问数据库的时候会使用CAS机制来判断当前数据是否被修改过，如果当前值=期望值，那么它就会去访问数据库，如果不等于，就会去获取最新的值当作期望值，再去跟当前值比较，一直循环，知道访问结束，使用CAS机制可以大大提高并发的效率，因为CAS不会让线程阻塞，通过一个自旋锁也就是一个死循环来空转，因为线程处理的过程非常快，所以一般自旋一下就好了，如果使用传统的锁机制的话，会使线程阻塞，然后再等线程恢复，这种线程状态的切换比较消耗cpu的资源。
   >
   > 悲观锁悲观地认为数据总在被修改，所以会直接加上一个锁，简单粗暴，悲观锁一般适用与数据库操作时间稍微较长的场景，因为这种时候任然适用CAS机制的话，死循环在那空转时间会很长，让CPU一下子打满。

   

6.  乐观锁如何保证线程安全？

7.  用过线程池吗，对应的好处，如何用？

8.  两个10G的文件，里面是一些url，内存只有1G，如何将这两个文件合并，找到相同的url？

   > 可以同过布隆过滤器
   >
   > 对10G的文件中的`url`进行多次hash，然后定位到布隆过滤器的位图上
   >
   > 然后对另一个文件的url进行多次相同的hash，然后判断多次哈希的值，是否都能存在布隆过滤器的位图上
   >
   > 如果都能对应，那么说明该url可能相同，如果不能对应，那么说明该url一定不相同，

9.  1000个多并发线程，10台机器，每台机器4核的，设计线程池大小。

10.  代码题：两个有序数组，数组中存在重复数字，合并成一个有序数组，去除重复数字。

    > 通过两个有序数组合成一个数组，然后将元素放置TreeSet中进行去重，
    >
    > 然后再将元素取出，重新放入一个list集合中，然后就已经是有序的了

11.  说一下自己的优点。

    > 自驱动学习
    >
    > 学习理解快
    >
    > 能学以致用

## 支付宝三面 

1.  jvm性能调优都做了什么

   > 设置初始堆栈的大小以避免堆溢出，栈溢出
   >
   > 设置不同场景设置不同的垃圾回收器

2.  数据库性能调优如何做

   > 优化sql
   >
   > 优化索引
   >
   > 最主要的还是优化业务，因为一切数据库层面的优化，都抵不过业务层面的优化

3.  分布式系统原理：CAP，最终一致性，幂等操作等

   > Consistency 一致性
   >
   > Avalabilty 可用性
   >
   > Partition tolerance 分区容错性
   >
   > 这三点不能同时满足
   >
   > 在大部分互联网场景下，一般都是牺牲强一致性，也就是满足AP，高可用性和分区容错性，一致性可以使用最终一致性来弥补
   >
   > 幂等操作是指一个相同请求多次发送，最终只有第一次生效
   >
   > 可以通过唯一标识来实现，假如往数据库里新增一条数据，给唯一标识字段添加一个唯一索引，然后再次新增的时候就会报错，

4.  高并发情况下，我们系统是如何支撑大量的请求的

   > 最终思想是使用集群思想来分散请求到各个服务器上，假如分散之后的请求还是很大的话，其实还是可以新增机器，也可以配合一些别的中间件来使用
   >
   > 比如分散之后的流量还是很大，此时可以引入消息中间件来实现流量的削峰，保证消费的速度在机器的承载范围之内，然后对生产请求做熔断或者降级处理，给其中一部分用户返回提示信息，告知系统繁忙之类的。
   >
   > 还可以配合缓存来使用，让大量的请求直接在缓存层就返回，只有少量的请求打到数据库，假如这个少量的请求还是很多的话，就可以考虑做数据库的集群，配合一些分库分表的中间件，实现大表分为表，大库分为小库，然后做多主多从的数据库集群，分散请求到不同数据库中，
   >
   > 高并发的最终思想就是分流，削峰，异步处理，熔断，降级这些个策略，具体根据实际场景来确认

5.  集群如何同步会话状态

   > 有些集群需要依赖zookeeper，就可以通过zookeeper的集群管理功能，来同步集群中的节点
   >
   > 有些集群不需要依赖zookeeper，一般都可以通过自身提供的集群方式来实现同步会话，比如数据库的binlog数据同步，redis的rdb配合aof同步数据到slave节点

6.  常用NOSQL，有做过比较?

   > redis，memcached，mongodb
   >
   > redis比memcached拥有更丰富的数据结构和API操作，redis支持服务端更新，而memcached是将数据取回到客户端更新后再写回去
   >
   > redis支持原生集群部署，memcached不支持
   >
   > redis是单线程模型，memcached是多线程模型，但是在存储小数据类型的时候redis更快
   >
   > mongodb是nosql比较特殊的一类，它是nosql中最像关系型数据的，因为它和关系型数据中有很多相同的概念，比如
   >
   > - database（数据库）
   > - collection（数据表）
   > - document（数据行）
   > - field（字段/列名）
   > - index（索引）
   >
   > 而且这种结构化比较灵活，

7.  什么情况会出现雪崩，以及如何应对？

   > 缓存中的大量key某一时刻同时过期，导致大量请求直接打到数据库
   >
   > 事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃
   >
   > 事中：本地`ehcache`作为二级缓存 + `hystrix限流`&`降级`，避免MySQL被打死
   >
   > 事后：redis持久化，快速恢复缓存数据

8.  负载均衡的原理

9.  数据库事务属性

10.  与同事沟通的时候，如果遇到冲突了如何解决？

11.  工作中觉得哪方面欠缺？

12.  有问题要问么？

13.  期望薪水？

14.  为什么要离开现在的公司？